/*! Orb.js 05-05-2015 */
"use strict";var orb=orb||{revision:0};orb.Clock=function(a){this.autoStart=void 0!==a?a:!0,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.localTime=0,this.localElapsedTime=0,this.multiplier=1,this.running=!1,this.frame={diff:0,delta:0}},orb.Clock.prototype={constructor:orb.Clock,start:function(){this.startTime=void 0!==performance&&void 0!==performance.now?performance.now():Date.now(),this.oldTime=this.startTime,this.localTime=Date.now(),this.running=!0},stop:function(){this.getElapsedTime(),this.running=!1},getElapsedTime:function(){return this.getDelta(),this.elapsedTime},getLocalElapsedTime:function(){return this.getDelta(),this.localElapsedTime},getLocalTime:function(){return this.getDelta(),this.localTime},getDelta:function(){var a=0,b=0;if(this.autoStart&&!this.running&&this.start(),this.running){var c=void 0!==performance&&void 0!==performance.now?performance.now():Date.now();a=.001*(c-this.oldTime),b=a*this.multiplier,this.oldTime=c,this.elapsedTime+=a,this.localTime+=b,this.localElapsedTime+=b}return this.frame.diff=a,this.frame.delta=b,this.frame}},orb.Core=function(a){this.layers=[],this.overlays=[],this.animating=!1,this.renderer=new THREE.WebGLRenderer({antialias:!1}),this.scene=new THREE.Scene,this.camera=new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,1,1e12),this.camera.position.z=300;var b=this.renderer;b.setSize(window.innerWidth,window.innerHeight),b.setClearColor(0,1),this.clock=new orb.Clock,a.appendChild(this.renderer.domElement);var c=this;window.addEventListener("resize",function(){c.camera.aspect=window.innerWidth/window.innerHeight,c.camera.updateProjectionMatrix(),c.renderer.setSize(window.innerWidth,window.innerHeight),void 0!=orb.trackball&&orb.trackball.handleResize()},!1)},orb.Core.prototype={constructor:orb.Core,setDate:function(a){return a instanceof Date&&(this._date=a),this},getDate:function(a){return void 0===this._date,Date.now()},add:function(a){this.scene.add(a.scene),this.layers.push(a)},remove:function(a){this.scene.remove(a.scene);var b=this.layers.indexOf(a);b>-1&&this.layers.splice(b,1)},start:function(){if(!this.animating){var a=this,b=function(){a.animating&&(requestAnimationFrame(b),a.render())};this.animating=!0,requestAnimationFrame(b)}},stop:function(){this.animating=!1},render:function(){void 0!=orb.trackball&&orb.trackball.update();var a=this.clock.getLocalElapsedTime();orb.time.update(0,50*a);for(var b=0;b<this.layers.length;++b)this.layers[b].onUpdate(a);this.renderer.render(this.scene,this.camera),void 0!==stats&&stats.update()}},orb.Global=function(a){},orb.Global.prototype={},orb.Layer=function(){this.scene=new THREE.Object3D},orb.Layer.prototype={constructor:orb.Layer,onUpdate:function(){}},orb.Constants={Fragment:{},Vertex:{}},orb.Constants.Atmosphere={Kr:.0025,Km:.001,ESun:20,g:-.95,wavelength:[.65,.57,.475],scaleDepth:.25,mieScaleDepth:.1,innerRadius:100,outerRadius:101},orb.Constants.BV=[10203903,10401279,10729983,11190271,11716095,12307711,12899071,13424895,13884927,14344959,14673407,15002111,15330559,15659007,15987455,16316159,16710143,16775675,16775157,16774639,16774122,16773605,16773088,16772571,16772054,16771538,16771278,16770762,16770502,16769987,16769727,16769211,16768952,16768436,16767920,16767661,16767145,16766629,16766369,16765596,16765078,16764047,16763013,16761208,16758629,16755019,16749859,16743168,16732672],orb.Constants.Fragment.Earth="//\n// Atmospheric scattering fragment shader\n//\n// Author: Sean O'Neil\n//\n// Copyright (c) 2004 Sean O'Neil\n//\n// Ported for use with three.js/WebGL by James Baicoianu\n\n//uniform sampler2D s2Tex1;\n//uniform sampler2D s2Tex2;\n\nuniform float fNightScale;\nuniform vec3 v3LightPosition;\nuniform sampler2D tDiffuse;\n//uniform sampler2D tDiffuseNight;\n//uniform sampler2D tClouds;\n\nuniform float fMultiplier;\n\nvarying vec3 c0;\nvarying vec3 c1;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main (void)\n{\n	//gl_FragColor = vec4(c0, 1.0);\n	//gl_FragColor = vec4(0.25 * c0, 1.0);\n	//gl_FragColor = gl_Color + texture2D(s2Tex1, gl_TexCoord[0].st) * texture2D(s2Tex2, gl_TexCoord[1].st) * gl_SecondaryColor;\n	float phong = max(dot(normalize(-vNormal), normalize(v3LightPosition)), 0.0);\n\n	vec3 diffuseTex = texture2D( tDiffuse, vUv ).xyz;\n	//vec3 diffuseNightTex = texture2D( tDiffuseNight, vUv ).xyz;\n\n	//diffuseTex = vec3(0.0);\n	//diffuseNightTex = vec3(0.0);\n	//vec3 cloudsTex = texture2D( tClouds, vUv ).xyz;\n\n	//vec3 day = max( diffuseTex, cloudsTex ) * c0;\n	//vec3 night = fNightScale * (0.7 * pow(diffuseNightTex, vec3(3)) + 0.3 * diffuseNightTex) * (1.0 - c0) * phong * (1.0 - cloudsTex);\n\n\n\n	// specular\n	//vec3 r = reflect( -normalize(v3LightPosition), normalize(vNormal) );\n	//float specular =  0.2 * pow(max(dot(r, normalize(cameraPosition)), 0.0), 3.0);\n\n\n\n\n\n	//gl_FragColor = vec4(c1, 1.0) + vec4(day + night, 1.0);\n\n	//gl_FragColor = vec4(fMultiplier * (c1 + day + night), 1.0);\n	gl_FragColor = vec4(c1 + c0 * diffuseTex, 1.0);\n	//gl_FragColor.r += specular;\n	//gl_FragColor.rg += vUv.xy;\n\n}",orb.Constants.Fragment.RibbonUpdate="// update the ribbon shader\n\nvarying vec2 vUv;\n\nuniform sampler2D tPositions;\nuniform sampler2D tVelocities;\n\nuniform float delta;\n\nvoid main() {\n\n	vec2 uv = gl_FragCoord.xy / resolution.xy;\n	vec4 data = texture2D( tPosition, uv );\n	vec3 position = data.xy;\n	vec3 velocity = texture3D( tVelocity, position.xy ).xy;\n\n	// x = lng\n	// y = lat\n	gl_FragColor = vec4( position + velocity * delta, 1., 1. );\n\n}",orb.Constants.Fragment.Sky="//\n// Atmospheric scattering fragment shader\n//\n// Author: Sean O'Neil\n//\n// Copyright (c) 2004 Sean O'Neil\n//\n\nuniform vec3 v3LightPos;\nuniform float g;\nuniform float g2;\n\nuniform float fMultiplier;\n\nvarying vec3 v3Direction;\nvarying vec3 c0;\nvarying vec3 c1;\n\n// Calculates the Mie phase function\nfloat getMiePhase(float fCos, float fCos2, float g, float g2)\n{\n	return 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCos2) / pow(1.0 + g2 - 2.0 * g * fCos, 1.5);\n}\n\n// Calculates the Rayleigh phase function\nfloat getRayleighPhase(float fCos2)\n{\n	return 0.75 + 0.75 * fCos2;\n}\n\nvoid main (void)\n{\n	float fCos = dot(v3LightPos, v3Direction) / length(v3Direction);\n	float fCos2 = fCos * fCos;\n\n	vec3 color =	getRayleighPhase(fCos2) * c0 +\n					getMiePhase(fCos, fCos2, g, g2) * c1;\n\n 	gl_FragColor = vec4(fMultiplier * fMultiplier * color, 1.0);\n	gl_FragColor.a = gl_FragColor.b;\n}",orb.Constants.Fragment.Stars="uniform vec3 color;\nuniform sampler2D texture;\n\nvarying vec3 vColor;\n\nvoid main() {\n\n	gl_FragColor = vec4( color * vColor, 1.0 );\n	//gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );\n	//gl_FragColor = vec4( 1.0, 1.0, 1.0, 1.0 );\n}",orb.Constants.Vertex.Earth="//\n// Atmospheric scattering vertex shader\n//\n// Author: Sean O'Neil\n//\n// Copyright (c) 2004 Sean O'Neil\n//\n// Ported for use with three.js/WebGL by James Baicoianu\n\nuniform vec3 v3LightPosition;		// The direction vector to the light source\nuniform vec3 v3InvWavelength;	// 1 / pow(wavelength, 4) for the red, green, and blue channels\nuniform float fCameraHeight;	// The camera's current height\nuniform float fCameraHeight2;	// fCameraHeight^2\nuniform float fOuterRadius;		// The outer (atmosphere) radius\nuniform float fOuterRadius2;	// fOuterRadius^2\nuniform float fInnerRadius;		// The inner (planetary) radius\nuniform float fInnerRadius2;	// fInnerRadius^2\nuniform float fKrESun;			// Kr * ESun\nuniform float fKmESun;			// Km * ESun\nuniform float fKr4PI;			// Kr * 4 * PI\nuniform float fKm4PI;			// Km * 4 * PI\nuniform float fScale;			// 1 / (fOuterRadius - fInnerRadius)\nuniform float fScaleDepth;		// The scale depth (i.e. the altitude at which the atmosphere's average density is found)\nuniform float fScaleOverScaleDepth;	// fScale / fScaleDepth\nuniform sampler2D tDiffuse;\n\nvarying vec3 c0;\nvarying vec3 c1;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nconst int nSamples = 3;\nconst float fSamples = 3.0;\n\nfloat scale(float fCos)\n{\n	float x = 1.0 - fCos;\n	return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\n\nvoid main(void)\n{\n	// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n	vec3 v3Ray = position - cameraPosition;\n	float fFar = length(v3Ray);\n	v3Ray /= fFar;\n\n	// Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\n	float B = 2.0 * dot(cameraPosition, v3Ray);\n	float C = fCameraHeight2 - fOuterRadius2;\n	float fDet = max(0.0, B*B - 4.0 * C);\n	float fNear = 0.5 * (-B - sqrt(fDet));\n\n	// Calculate the ray's starting position, then calculate its scattering offset\n	vec3 v3Start = cameraPosition + v3Ray * fNear;\n	fFar -= fNear;\n	float fDepth = exp((fInnerRadius - fOuterRadius) / fScaleDepth);\n	float fCameraAngle = dot(-v3Ray, position) / length(position);\n	float fLightAngle = dot(v3LightPosition, position) / length(position);\n	float fCameraScale = scale(fCameraAngle);\n	float fLightScale = scale(fLightAngle);\n	float fCameraOffset = fDepth*fCameraScale;\n	float fTemp = (fLightScale + fCameraScale);\n\n	// Initialize the scattering loop variables\n	float fSampleLength = fFar / fSamples;\n	float fScaledLength = fSampleLength * fScale;\n	vec3 v3SampleRay = v3Ray * fSampleLength;\n	vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n	// Now loop through the sample rays\n	vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n	vec3 v3Attenuate;\n	for(int i=0; i<nSamples; i++)\n	{\n		float fHeight = length(v3SamplePoint);\n		float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n		float fScatter = fDepth*fTemp - fCameraOffset;\n		v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n		v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n		v3SamplePoint += v3SampleRay;\n	}\n\n	// Calculate the attenuation factor for the ground\n	c0 = v3Attenuate;\n	c1 = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\n\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n	//gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;\n	//gl_TexCoord[1] = gl_TextureMatrix[1] * gl_MultiTexCoord1;\n	vUv = uv;\n	vNormal = normal;\n}",orb.Constants.Vertex.EarthMap="//\n// Atmospheric scattering vertex shader\n//\n// Author: Sean O'Neil\n//\n// Copyright (c) 2004 Sean O'Neil\n//\n// Ported for use with three.js/WebGL by James Baicoianu\n\nuniform vec3 v3LightPosition;		// The direction vector to the light source\nuniform vec3 v3InvWavelength;	// 1 / pow(wavelength, 4) for the red, green, and blue channels\nuniform float fCameraHeight;	// The camera's current height\nuniform float fCameraHeight2;	// fCameraHeight^2\nuniform float fOuterRadius;		// The outer (atmosphere) radius\nuniform float fOuterRadius2;	// fOuterRadius^2\nuniform float fInnerRadius;		// The inner (planetary) radius\nuniform float fInnerRadius2;	// fInnerRadius^2\nuniform float fKrESun;			// Kr * ESun\nuniform float fKmESun;			// Km * ESun\nuniform float fKr4PI;			// Kr * 4 * PI\nuniform float fKm4PI;			// Km * 4 * PI\nuniform float fScale;			// 1 / (fOuterRadius - fInnerRadius)\nuniform float fScaleDepth;		// The scale depth (i.e. the altitude at which the atmosphere's average density is found)\nuniform float fScaleOverScaleDepth;	// fScale / fScaleDepth\nuniform sampler2D tDiffuse;\n\nvarying vec3 c0;\nvarying vec3 c1;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nconst int nSamples = 3;\nconst float fSamples = 3.0;\n\nfloat scale(float fCos)\n{\n	float x = 1.0 - fCos;\n	return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\n\nvoid main(void)\n{\n	// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n	float theta = (uv.y) * 3.1415;\n	float phi = (uv.x) * 2.0 * 3.1415;\n\n	vec3 v3position = -vec3( fInnerRadius * sin(theta) * cos(phi), fInnerRadius * sin(theta) * sin(phi), fInnerRadius * cos(theta) );\n	vec3 v3camera = 6.0 * v3position;\n	float ffCameraHeight = length(v3camera);\n	float ffCameraHeight2 = ffCameraHeight * ffCameraHeight;\n	vec3 v3Ray = v3position - v3camera;\n	float fFar = length(v3Ray);\n	v3Ray /= fFar;\n\n	// Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\n	float B = 2.0 * dot(v3camera, v3Ray);\n	float C = ffCameraHeight2 - fOuterRadius2;\n	float fDet = max(0.0, B*B - 4.0 * C);\n	float fNear = 0.5 * (-B - sqrt(fDet));\n\n	// Calculate the ray's starting position, then calculate its scattering offset\n	vec3 v3Start = v3camera + v3Ray * fNear;\n	fFar -= fNear;\n	float fDepth = exp((fInnerRadius - fOuterRadius) / fScaleDepth);\n	float fCameraAngle = dot(-v3Ray, v3position) / length(v3position);\n	float fLightAngle = dot(v3LightPosition, v3position) / length(v3position);\n	float fCameraScale = scale(fCameraAngle);\n	float fLightScale = scale(fLightAngle);\n	float fCameraOffset = fDepth*fCameraScale;\n	float fTemp = (fLightScale + fCameraScale);\n\n	// Initialize the scattering loop variables\n	float fSampleLength = fFar / fSamples;\n	float fScaledLength = fSampleLength * fScale;\n	vec3 v3SampleRay = v3Ray * fSampleLength;\n	vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n	// Now loop through the sample rays\n	vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n	vec3 v3Attenuate;\n	for(int i=0; i < nSamples; i++)\n	{\n		float fHeight = length(v3SamplePoint);\n		float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n		float fScatter = fDepth*fTemp - fCameraOffset;\n		v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n		v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n		v3SamplePoint += v3SampleRay;\n	}\n\n	// Calculate the attenuation factor for the ground\n	c0 = v3Attenuate;\n	c1 = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\n	//c0 = vec3( uv.u, uv.v, 0 );\n\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n	//gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;\n	//gl_TexCoord[1] = gl_TextureMatrix[1] * gl_MultiTexCoord1;\n	vUv = uv;\n	vNormal = normal;\n}",orb.Constants.Vertex.RibbonUpdate="varying vec2 vUv;\n\nvoid main() {\n\n	vUv = vec2(uv.x, 1.0 - uv.y);\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}",orb.Constants.Vertex.Sky="//\n// Atmospheric scattering vertex shader\n//\n// Author: Sean O'Neil\n//\n// Copyright (c) 2004 Sean O'Neil\n//\n\nuniform vec3 v3LightPosition;	// The direction vector to the light source\nuniform vec3 v3InvWavelength;	// 1 / pow(wavelength, 4) for the red, green, and blue channels\nuniform float fCameraHeight;	// The camera's current height\nuniform float fCameraHeight2;	// fCameraHeight^2\nuniform float fOuterRadius;		// The outer (atmosphere) radius\nuniform float fOuterRadius2;	// fOuterRadius^2\nuniform float fInnerRadius;		// The inner (planetary) radius\nuniform float fInnerRadius2;	// fInnerRadius^2\nuniform float fKrESun;			// Kr * ESun\nuniform float fKmESun;			// Km * ESun\nuniform float fKr4PI;			// Kr * 4 * PI\nuniform float fKm4PI;			// Km * 4 * PI\nuniform float fScale;			// 1 / (fOuterRadius - fInnerRadius)\nuniform float fScaleDepth;		// The scale depth (i.e. the altitude at which the atmosphere's average density is found)\nuniform float fScaleOverScaleDepth;	// fScale / fScaleDepth\n\nconst int nSamples = 3;\nconst float fSamples = 3.0;\n\nvarying vec3 v3Direction;\nvarying vec3 c0;\nvarying vec3 c1;\n\n\nfloat scale(float fCos)\n{\n	float x = 1.0 - fCos;\n	return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\n\nvoid main(void)\n{\n	// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n	vec3 v3Ray = position - cameraPosition;\n	float fFar = length(v3Ray);\n	v3Ray /= fFar;\n\n	// Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\n	float B = 2.0 * dot(cameraPosition, v3Ray);\n	float C = fCameraHeight2 - fOuterRadius2;\n	float fDet = max(0.0, B*B - 4.0 * C);\n	float fNear = 0.5 * (-B - sqrt(fDet));\n\n	// Calculate the ray's starting position, then calculate its scattering offset\n	vec3 v3Start = cameraPosition + v3Ray * fNear;\n	fFar -= fNear;\n	float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;\n	float fStartDepth = exp(-1.0 / fScaleDepth);\n	float fStartOffset = fStartDepth * scale(fStartAngle);\n	//c0 = vec3(1.0, 0, 0) * fStartAngle;\n\n	// Initialize the scattering loop variables\n	float fSampleLength = fFar / fSamples;\n	float fScaledLength = fSampleLength * fScale;\n	vec3 v3SampleRay = v3Ray * fSampleLength;\n	vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n	//gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);\n\n	// Now loop through the sample rays\n	vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n	for(int i=0; i<nSamples; i++)\n	{\n		float fHeight = length(v3SamplePoint);\n		float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n		float fLightAngle = dot(v3LightPosition, v3SamplePoint) / fHeight;\n		float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight;\n		float fScatter = (fStartOffset + fDepth * (scale(fLightAngle) - scale(fCameraAngle)));\n		vec3 v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n\n		v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n		v3SamplePoint += v3SampleRay;\n	}\n\n	// Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n	c0 = v3FrontColor * (v3InvWavelength * fKrESun);\n	c1 = v3FrontColor * fKmESun;\n	v3Direction = cameraPosition - position;\n}",orb.Constants.Vertex.Stars="attribute float size;\nattribute vec3 ca;\n\nvarying vec3 vColor;\n\nvoid main() {\n\n	vColor = ca;\n\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n	//gl_PointSize = size;\n	//gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );\n	gl_PointSize = 1.5;\n\n	gl_Position = projectionMatrix * mvPosition;\n\n}",orb.time={day:0,minute:0,declination:0,spin:0,euler:new THREE.Euler,matrix:new THREE.Matrix4,update:function(a,b){for(void 0!==a&&void 0!=b&&(this.day=a,this.minute=b);this.minute>1440;)this.minute-=1440,this.day+=1;this.day>365&&(this.day=this.day%365),this.declination=-23.45*Math.PI/180*Math.cos(2*Math.PI/365*(this.day+10)),this.spin=-2*Math.PI*(this.minute/1440),this.euler.y=this.spin+Math.PI,this.euler.z=this.declination,this.matrix.makeRotationFromEuler(this.euler)}},orb.GlobeControls=function(a,b){function c(a){l.enabled!==!1&&(window.removeEventListener("keydown",c),q=p,p===m.NONE&&(a.keyCode!==l.keys[m.ROTATE]||l.noRotate?a.keyCode!==l.keys[m.ZOOM]||l.noZoom?a.keyCode!==l.keys[m.PAN]||l.noPan||(p=m.PAN):p=m.ZOOM:p=m.ROTATE))}function d(a){l.enabled!==!1&&(p=q,window.addEventListener("keydown",c,!1))}function e(a){l.enabled!==!1&&(a.preventDefault(),a.stopPropagation(),p===m.NONE&&(p=a.button),p!==m.ROTATE||l.noRotate?p!==m.ZOOM||l.noZoom?p!==m.PAN||l.noPan||(A.copy(F(a.pageX,a.pageY)),B.copy(A)):(w.copy(F(a.pageX,a.pageY)),x.copy(w)):(t.copy(G(a.pageX,a.pageY)),s.copy(t)),document.addEventListener("mousemove",f,!1),document.addEventListener("mouseup",g,!1),l.dispatchEvent(D))}function f(a){l.enabled!==!1&&(a.preventDefault(),a.stopPropagation(),p!==m.ROTATE||l.noRotate?p!==m.ZOOM||l.noZoom?p!==m.PAN||l.noPan||B.copy(F(a.pageX,a.pageY)):x.copy(F(a.pageX,a.pageY)):(s.copy(t),t.copy(G(a.pageX,a.pageY))))}function g(a){l.enabled!==!1&&(a.preventDefault(),a.stopPropagation(),p=m.NONE,document.removeEventListener("mousemove",f),document.removeEventListener("mouseup",g),l.dispatchEvent(E))}function h(a){if(l.enabled!==!1){a.preventDefault(),a.stopPropagation();var b=0;a.wheelDelta?b=a.wheelDelta/40:a.detail&&(b=-a.detail/3),w.y+=.01*b,l.dispatchEvent(D),l.dispatchEvent(E)}}function i(a){if(l.enabled!==!1){switch(a.touches.length){case 1:p=m.TOUCH_ROTATE,t.copy(G(a.touches[0].pageX,a.touches[0].pageY)),s.copy(t);break;case 2:p=m.TOUCH_ZOOM_PAN;var b=a.touches[0].pageX-a.touches[1].pageX,c=a.touches[0].pageY-a.touches[1].pageY;z=y=Math.sqrt(b*b+c*c);var d=(a.touches[0].pageX+a.touches[1].pageX)/2,e=(a.touches[0].pageY+a.touches[1].pageY)/2;A.copy(F(d,e)),B.copy(A);break;default:p=m.NONE}l.dispatchEvent(D)}}function j(a){if(l.enabled!==!1)switch(a.preventDefault(),a.stopPropagation(),a.touches.length){case 1:s.copy(t),t.copy(G(a.touches[0].pageX,a.touches[0].pageY));break;case 2:var b=a.touches[0].pageX-a.touches[1].pageX,c=a.touches[0].pageY-a.touches[1].pageY;z=Math.sqrt(b*b+c*c);var d=(a.touches[0].pageX+a.touches[1].pageX)/2,e=(a.touches[0].pageY+a.touches[1].pageY)/2;B.copy(F(d,e));break;default:p=m.NONE}}function k(a){if(l.enabled!==!1){switch(a.touches.length){case 1:s.copy(t),t.copy(G(a.touches[0].pageX,a.touches[0].pageY));break;case 2:y=z=0;var b=(a.touches[0].pageX+a.touches[1].pageX)/2,c=(a.touches[0].pageY+a.touches[1].pageY)/2;B.copy(F(b,c)),A.copy(B)}p=m.NONE,l.dispatchEvent(E)}}var l=this,m={NONE:-1,ROTATE:0,ZOOM:1,PAN:2,TOUCH_ROTATE:3,TOUCH_ZOOM_PAN:4};this.object=a,this.domElement=void 0!==b?b:document,this.enabled=!0,this.screen={left:0,top:0,width:0,height:0},this.rotateSpeed=1,this.zoomSpeed=1.2,this.panSpeed=.3,this.noRotate=!1,this.noZoom=!1,this.noPan=!1,this.staticMoving=!0,this.dynamicDampingFactor=.2,this.exponentialZoom=!0,this.baseDistance=0,this.minDistance=0,this.maxDistance=1/0,this.keys=[65,83,68],this.target=new THREE.Vector3;var n=1e-6,o=new THREE.Vector3,p=m.NONE,q=m.NONE,r=new THREE.Vector3,s=new THREE.Vector2,t=new THREE.Vector2,u=new THREE.Vector3,v=0,w=new THREE.Vector2,x=new THREE.Vector2,y=0,z=0,A=new THREE.Vector2,B=new THREE.Vector2;this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.up0=this.object.up.clone();var C={type:"change"},D={type:"start"},E={type:"end"};this.handleResize=function(){if(this.domElement===document)this.screen.left=0,this.screen.top=0,this.screen.width=window.innerWidth,this.screen.height=window.innerHeight;else{var a=this.domElement.getBoundingClientRect(),b=this.domElement.ownerDocument.documentElement;this.screen.left=a.left+window.pageXOffset-b.clientLeft,this.screen.top=a.top+window.pageYOffset-b.clientTop,this.screen.width=a.width,this.screen.height=a.height}},this.handleEvent=function(a){"function"==typeof this[a.type]&&this[a.type](a)};var F=function(){var a=new THREE.Vector2;return function(b,c){return a.set((b-l.screen.left)/l.screen.width,(c-l.screen.top)/l.screen.height),a}}(),G=function(){var a=new THREE.Vector2;return function(b,c){return a.set((b-.5*l.screen.width-l.screen.left)/(.5*l.screen.width),(l.screen.height+2*(l.screen.top-c))/l.screen.width),a}}();this.rotateCamera=function(){var a,b=new THREE.Vector3,c=new THREE.Quaternion,d=new THREE.Vector3,e=new THREE.Vector3,f=new THREE.Vector3,g=new THREE.Vector3;return function(){g.set(t.x-s.x,t.y-s.y,0),a=g.length(),a?(r.copy(l.object.position).sub(l.target),d.copy(r).normalize(),e.copy(l.object.up).normalize(),f.crossVectors(e,d).normalize(),e.setLength(t.y-s.y),f.setLength(t.x-s.x),g.copy(e.add(f)),b.crossVectors(g,r).normalize(),a*=l.rotateSpeed,c.setFromAxisAngle(b,a),r.applyQuaternion(c),l.object.up.applyQuaternion(c),u.copy(b),v=a):!l.staticMoving&&v&&(v*=Math.sqrt(1-l.dynamicDampingFactor),r.copy(l.object.position).sub(l.target),c.setFromAxisAngle(u,v),r.applyQuaternion(c),l.object.up.applyQuaternion(c)),s.copy(t)}}(),this.zoomCamera=function(){var a;if(p===m.TOUCH_ZOOM_PAN)a=y/z,y=z,r.multiplyScalar(a);else if(a=1+(x.y-w.y)*l.zoomSpeed,1!==a&&a>0){var b=a=(x.y-w.y)*l.zoomSpeed;l._zoomFactor+=b,r.setLength(l.baseDistance+Math.exp(l._zoomFactor)),console.log(l._zoomFactor),l._zoomFactor>Math.log(l.maxDistance-l.baseDistance)&&(l._zoomFactor=Math.log(l.maxDistance-l.baseDistance)),l.staticMoving?w.copy(x):w.y+=(x.y-w.y)*this.dynamicDampingFactor}},this.panCamera=function(){var a=new THREE.Vector2,b=new THREE.Vector3,c=new THREE.Vector3;return function(){a.copy(B).sub(A),a.lengthSq()&&(a.multiplyScalar(r.length()*l.panSpeed),c.copy(r).cross(l.object.up).setLength(a.x),c.add(b.copy(l.object.up).setLength(a.y)),l.object.position.add(c),l.target.add(c),l.staticMoving?A.copy(B):A.add(a.subVectors(B,A).multiplyScalar(l.dynamicDampingFactor)))}}(),this.checkDistances=function(){l.noZoom&&l.noPan||(r.lengthSq()>l.maxDistance*l.maxDistance&&l.object.position.addVectors(l.target,r.setLength(l.maxDistance)),r.lengthSq()<l.minDistance*l.minDistance&&l.object.position.addVectors(l.target,r.setLength(l.minDistance)))},this.update=function(){r.subVectors(l.object.position,l.target),l._zoomFactor=Math.log(r.length()-l.baseDistance),l.noRotate||l.rotateCamera(),l.noZoom||l.zoomCamera(),l.noPan||l.panCamera(),l.object.position.addVectors(l.target,r),l.checkDistances(),l.object.lookAt(l.target),o.distanceToSquared(l.object.position)>n&&(l.dispatchEvent(C),o.copy(l.object.position))},this.reset=function(){p=m.NONE,q=m.NONE,l.target.copy(l.target0),l.object.position.copy(l.position0),l.object.up.copy(l.up0),r.subVectors(l.object.position,l.target),l.object.lookAt(l.target),l.dispatchEvent(C),o.copy(l.object.position)},this.domElement.addEventListener("contextmenu",function(a){a.preventDefault()},!1),this.domElement.addEventListener("mousedown",e,!1),this.domElement.addEventListener("mousewheel",h,!1),this.domElement.addEventListener("DOMMouseScroll",h,!1),this.domElement.addEventListener("touchstart",i,!1),this.domElement.addEventListener("touchend",k,!1),this.domElement.addEventListener("touchmove",j,!1),window.addEventListener("keydown",c,!1),window.addEventListener("keyup",d,!1),this.handleResize(),this.update()},orb.GlobeControls.prototype=Object.create(THREE.EventDispatcher.prototype),orb.GlobeControls.prototype.constructor=orb.GlobeControls,orb.MapControls=function(a,b){function c(a){l.enabled!==!1&&(window.removeEventListener("keydown",c),q=p,p===m.NONE&&(a.keyCode!==l.keys[m.ROTATE]||l.noRotate?a.keyCode!==l.keys[m.ZOOM]||l.noZoom?a.keyCode!==l.keys[m.PAN]||l.noPan||(p=m.PAN):p=m.ZOOM:p=m.ROTATE))}function d(a){l.enabled!==!1&&(p=q,window.addEventListener("keydown",c,!1))}function e(a){l.enabled!==!1&&(a.preventDefault(),a.stopPropagation(),p===m.NONE&&(p=a.button),p!==m.ROTATE||l.noRotate?p!==m.ZOOM||l.noZoom?p!==m.PAN||l.noPan||(A.copy(F(a.pageX,a.pageY)),B.copy(A)):(w.copy(F(a.pageX,a.pageY)),x.copy(w)):(t.copy(G(a.pageX,a.pageY)),s.copy(t)),document.addEventListener("mousemove",f,!1),document.addEventListener("mouseup",g,!1),l.dispatchEvent(D))}function f(a){l.enabled!==!1&&(a.preventDefault(),a.stopPropagation(),p!==m.ROTATE||l.noRotate?p!==m.ZOOM||l.noZoom?p!==m.PAN||l.noPan||B.copy(F(a.pageX,a.pageY)):x.copy(F(a.pageX,a.pageY)):(s.copy(t),t.copy(G(a.pageX,a.pageY))))}function g(a){l.enabled!==!1&&(a.preventDefault(),a.stopPropagation(),p=m.NONE,document.removeEventListener("mousemove",f),document.removeEventListener("mouseup",g),l.dispatchEvent(E))}function h(a){if(l.enabled!==!1){a.preventDefault(),a.stopPropagation();var b=0;a.wheelDelta?b=a.wheelDelta/40:a.detail&&(b=-a.detail/3),w.y+=.01*b,l.dispatchEvent(D),l.dispatchEvent(E)}}function i(a){if(l.enabled!==!1){switch(a.touches.length){case 1:p=m.TOUCH_ROTATE,t.copy(G(a.touches[0].pageX,a.touches[0].pageY)),s.copy(t);break;case 2:p=m.TOUCH_ZOOM_PAN;var b=a.touches[0].pageX-a.touches[1].pageX,c=a.touches[0].pageY-a.touches[1].pageY;z=y=Math.sqrt(b*b+c*c);var d=(a.touches[0].pageX+a.touches[1].pageX)/2,e=(a.touches[0].pageY+a.touches[1].pageY)/2;A.copy(F(d,e)),B.copy(A);break;default:p=m.NONE}l.dispatchEvent(D)}}function j(a){if(l.enabled!==!1)switch(a.preventDefault(),a.stopPropagation(),a.touches.length){case 1:s.copy(t),t.copy(G(a.touches[0].pageX,a.touches[0].pageY));break;case 2:var b=a.touches[0].pageX-a.touches[1].pageX,c=a.touches[0].pageY-a.touches[1].pageY;z=Math.sqrt(b*b+c*c);var d=(a.touches[0].pageX+a.touches[1].pageX)/2,e=(a.touches[0].pageY+a.touches[1].pageY)/2;B.copy(F(d,e));break;default:p=m.NONE}}function k(a){if(l.enabled!==!1){switch(a.touches.length){case 1:s.copy(t),t.copy(G(a.touches[0].pageX,a.touches[0].pageY));break;case 2:y=z=0;var b=(a.touches[0].pageX+a.touches[1].pageX)/2,c=(a.touches[0].pageY+a.touches[1].pageY)/2;B.copy(F(b,c)),A.copy(B)}p=m.NONE,l.dispatchEvent(E)}}var l=this,m={NONE:-1,ROTATE:2,ZOOM:1,PAN:0,TOUCH_ROTATE:3,TOUCH_ZOOM_PAN:4};this.object=a,this.domElement=void 0!==b?b:document,this.enabled=!0,this.screen={left:0,top:0,width:0,height:0},this.rotateSpeed=1,this.zoomSpeed=1.2,this.panSpeed=.3,this.noRotate=!0,this.noZoom=!1,this.noPan=!1,this.staticMoving=!0,this.dynamicDampingFactor=.2,this.exponentialZoom=!0,this.baseDistance=0,this.minDistance=0,this.maxDistance=1/0,this.keys=[65,83,68],this.target=new THREE.Vector3;var n=1e-6,o=new THREE.Vector3,p=m.NONE,q=m.NONE,r=new THREE.Vector3,s=new THREE.Vector2,t=new THREE.Vector2,u=new THREE.Vector3,v=0,w=new THREE.Vector2,x=new THREE.Vector2,y=0,z=0,A=new THREE.Vector2,B=new THREE.Vector2;this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.up0=this.object.up.clone();var C={type:"change"},D={type:"start"},E={type:"end"};this.handleResize=function(){if(this.domElement===document)this.screen.left=0,this.screen.top=0,this.screen.width=window.innerWidth,this.screen.height=window.innerHeight;else{var a=this.domElement.getBoundingClientRect(),b=this.domElement.ownerDocument.documentElement;this.screen.left=a.left+window.pageXOffset-b.clientLeft,this.screen.top=a.top+window.pageYOffset-b.clientTop,this.screen.width=a.width,this.screen.height=a.height}},this.handleEvent=function(a){"function"==typeof this[a.type]&&this[a.type](a)};var F=function(){var a=new THREE.Vector2;return function(b,c){return a.set((b-l.screen.left)/l.screen.width,(c-l.screen.top)/l.screen.height),a}}(),G=function(){var a=new THREE.Vector2;return function(b,c){return a.set((b-.5*l.screen.width-l.screen.left)/(.5*l.screen.width),(l.screen.height+2*(l.screen.top-c))/l.screen.width),a}}();this.rotateCamera=function(){var a,b=new THREE.Vector3,c=new THREE.Quaternion,d=new THREE.Vector3,e=new THREE.Vector3,f=new THREE.Vector3,g=new THREE.Vector3;return function(){g.set(t.x-s.x,t.y-s.y,0),a=g.length(),a?(r.copy(l.object.position).sub(l.target),d.copy(r).normalize(),e.copy(l.object.up).normalize(),f.crossVectors(e,d).normalize(),e.setLength(t.y-s.y),f.setLength(t.x-s.x),g.copy(e.add(f)),b.crossVectors(g,r).normalize(),a*=l.rotateSpeed,c.setFromAxisAngle(b,a),r.applyQuaternion(c),l.object.up.applyQuaternion(c),u.copy(b),v=a):!l.staticMoving&&v&&(v*=Math.sqrt(1-l.dynamicDampingFactor),r.copy(l.object.position).sub(l.target),c.setFromAxisAngle(u,v),r.applyQuaternion(c),l.object.up.applyQuaternion(c)),s.copy(t)}}(),this.zoomCamera=function(){var a;if(p===m.TOUCH_ZOOM_PAN)a=y/z,y=z,r.multiplyScalar(a);else if(a=1+(x.y-w.y)*l.zoomSpeed,1!==a&&a>0){var b=a=(x.y-w.y)*l.zoomSpeed;l._zoomFactor+=b,r.setLength(l.baseDistance+Math.exp(l._zoomFactor)),console.log(l._zoomFactor),l._zoomFactor>Math.log(l.maxDistance-l.baseDistance)&&(l._zoomFactor=Math.log(l.maxDistance-l.baseDistance)),l.staticMoving?w.copy(x):w.y+=(x.y-w.y)*this.dynamicDampingFactor}},this.panCamera=function(){var a=new THREE.Vector2,b=new THREE.Vector3,c=new THREE.Vector3;return function(){a.copy(B).sub(A),a.lengthSq()&&(a.multiplyScalar(r.length()*l.panSpeed),c.copy(r).cross(l.object.up).setLength(a.x),c.add(b.copy(l.object.up).setLength(a.y)),l.object.position.add(c),l.target.add(c),l.staticMoving?A.copy(B):A.add(a.subVectors(B,A).multiplyScalar(l.dynamicDampingFactor)))}}(),this.checkDistances=function(){l.noZoom&&l.noPan||(r.lengthSq()>l.maxDistance*l.maxDistance&&l.object.position.addVectors(l.target,r.setLength(l.maxDistance)),r.lengthSq()<l.minDistance*l.minDistance&&l.object.position.addVectors(l.target,r.setLength(l.minDistance)));
},this.update=function(){r.subVectors(l.object.position,l.target),l._zoomFactor=Math.log(r.length()-l.baseDistance),l.noRotate||l.rotateCamera(),l.noZoom||l.zoomCamera(),l.noPan||l.panCamera(),l.object.position.addVectors(l.target,r),l.checkDistances(),l.object.lookAt(l.target),o.distanceToSquared(l.object.position)>n&&(l.dispatchEvent(C),o.copy(l.object.position))},this.reset=function(){p=m.NONE,q=m.NONE,l.target.copy(l.target0),l.object.position.copy(l.position0),l.object.up.copy(l.up0),r.subVectors(l.object.position,l.target),l.object.lookAt(l.target),l.dispatchEvent(C),o.copy(l.object.position)},this.domElement.addEventListener("contextmenu",function(a){a.preventDefault()},!1),this.domElement.addEventListener("mousedown",e,!1),this.domElement.addEventListener("mousewheel",h,!1),this.domElement.addEventListener("DOMMouseScroll",h,!1),this.domElement.addEventListener("touchstart",i,!1),this.domElement.addEventListener("touchend",k,!1),this.domElement.addEventListener("touchmove",j,!1),window.addEventListener("keydown",c,!1),window.addEventListener("keyup",d,!1),this.handleResize(),this.update()},orb.MapControls.prototype=Object.create(THREE.EventDispatcher.prototype),orb.MapControls.prototype.constructor=orb.GlobeControls,THREE.SpaceNavigatorControls=function(a,b){this.updateGamepad=function(){var a=navigator.getGamepads();if(void 0!=a[0]){var b=a[0],c={left:b.buttons[0],right:b.buttons[1],x:b.axes[0],y:b.axes[1],z:b.axes[2],rx:b.axes[3],ry:b.axes[4],rz:b.axes[5]};_eye.multiplyScalar(-c.z+1),normalz.copy(_eye).normalize(),normalx.copy(_eye).cross(this.object.up).normalize();var d=(new THREE.Quaternion).setFromAxisAngle(normalx,c.rx),e=(new THREE.Quaternion).setFromAxisAngle(this.object.up,c.ry),f=(new THREE.Quaternion).setFromAxisAngle(normalz,c.rz);d.multiply(e).multiply(f),_eye.applyQuaternion(d),_this.object.up.applyQuaternion(d)}}},orb.ArcGeometry=function(a,b,c){THREE.Geometry.call(this);for(var d=a.toVector3(),e=b.toVector3(),f=10,g=0;f+1>g;++g){var h=(new THREE.Vector3).copy(d);h.lerp(e,g/f),h.normalize().multiplyScalar(c),this.vertices.push(h)}},orb.ArcGeometry.prototype=Object.create(THREE.Geometry.prototype),orb.RibbonGeometry=function(){THREE.Geometry.call(this)},orb.RibbonGeometry.prototype=Object.create(THREE.Geometry.prototype),orb.ArcLayer=function(a){orb.Layer.call(this);for(var b=new THREE.LineBasicMaterial({color:16777215}),c=0;c<a.length;++c){var d=a[c],e=d[0],f=d[1],g=new orb.ArcGeometry(e,f,100),h=new THREE.Line(g,b);this.scene.add(h)}},orb.ArcLayer.prototype=Object.create(orb.Layer.prototype),orb.AtmosphericLayer=function(){},orb.AtmosphericLayer.prototype=Object.create(orb.Layer.prototype),orb.AtmosphericInLayer=function(){},orb.AtmosphericOutLayer=function(){},orb.BarDataLayer=function(a,b){var c=[14277081,11973813,10053324,1420799,4089507,2187912,16744062,16719635,12587531,5903105,16763906,15577363,10473062,825913,16685170,8339352,15885602,2864755,14147363,15118906,8311799];orb.Layer.call(this);for(var d=new THREE.Geometry,e=new THREE.MeshBasicMaterial({color:13986863,depthWrite:!1,depthTest:!1,blending:THREE.AdditiveBlending,vertexColors:THREE.FaceColors,transparent:!0}),f=new orb.Coordinate,g=new THREE.Vector3,h=new THREE.BoxGeometry(1,1,1),i=new THREE.Mesh(h,void 0),j=0;j<a.length;j+=4){for(var k=a[j],l=a[j+1],m=Math.max(200*a[j+2],.1),n=a[j+3],o=new THREE.Color(c[n]),p=0;p<h.faces.length;p++)h.faces[p].color=o;f.set(k,l),f.toVector3(orb.Constants.Atmosphere.outerRadius,i.position),i.scale.set(.5,.5,m),i.lookAt(g),i.updateMatrix(),d.merge(i.geometry,i.matrix)}var q=new THREE.Mesh(d,e);this.scene.add(q)},orb.BarDataLayer.prototype=Object.create(orb.Layer.prototype),orb.FieldLayer=function(){this.lifespan=1,this.density=1e4,this.resolution=10,this.buffer=new Float32Array(this.density*this.resolution),this.geometry=new THREE.BufferedGeometry;this.geometry.attributes},orb.FieldLayer.prototype={constructor:orb.FieldLayer,update:function(){},randomPoint:function(){var a=Math.random(),b=Math.random(),c=2*Math.PI*a,d=Math.acos(2*b-1);return THREE.Vector3(Math.sin(c)*Math.cos(d),Math.sin(c)*Math.sin(d),Math.cos(c))}},orb.MapLayer=function(){orb.Layer.call(this),orb.textures={day:THREE.ImageUtils.loadTexture("textures/map-small.jpg")};var a=function(a,b){return{type:a,value:b}},b=orb.Constants.Atmosphere,c={v3LightPosition:a("v3",new THREE.Vector3(1e8,0,1e8).normalize()),v3InvWavelength:a("v3",new THREE.Vector3(1/Math.pow(b.wavelength[0],4),1/Math.pow(b.wavelength[1],4),1/Math.pow(b.wavelength[2],4))),fCameraHeight:a("f",0),fCameraHeight2:a("f",0),fInnerRadius:a("f",b.innerRadius),fInnerRadius2:a("f",b.innerRadius*b.innerRadius),fOuterRadius:a("f",b.outerRadius),fOuterRadius2:a("f",b.outerRadius*b.outerRadius),fKrESun:a("f",b.Kr*b.ESun),fKmESun:a("f",b.Km*b.ESun),fKr4PI:a("f",4*b.Kr*Math.PI),fKm4PI:a("f",4*b.Km*Math.PI),fScale:a("f",1/(b.outerRadius-b.innerRadius)),fScaleDepth:a("f",b.scaleDepth),fScaleOverScaleDepth:a("f",1/(b.outerRadius-b.innerRadius)/b.scaleDepth),g:a("f",b.g),g2:a("f",b.g*b.g),nSamples:a("i",3),fSamples:a("f",3),tDiffuse:a("t",orb.textures.day),tDiffuseNight:a("t",orb.textures.night),tClouds:a("t",null),fNightScale:a("f",1),fMultiplier:a("f",1)},d=new THREE.PlaneBufferGeometry(200,100,100,50),e=new THREE.ShaderMaterial({uniforms:c,vertexShader:orb.Constants.Vertex.EarthMap,fragmentShader:orb.Constants.Fragment.Earth,depthWrite:!0}),f=new THREE.Mesh(d,e);f.group="globe",this.scene.add(f);var g=new THREE.Vector3(1,1,0),h=(new THREE.Euler(0,0,0),new THREE.Matrix4,0);this.onUpdate=function(){h=orb.core.camera.position.length(),g.set(1,0,0),g.applyMatrix4(orb.time.matrix),c.v3LightPosition.value=g,c.fCameraHeight.value=h,c.fCameraHeight2.value=h*h}},orb.MapLayer.prototype=Object.create(orb.Layer.prototype),orb.GeometryLayer=function(){orb.Layer.call(this),orb.textures={day:THREE.ImageUtils.loadTexture("textures/map-small.jpg")};var a=function(a,b){return{type:a,value:b}},b=orb.Constants.Atmosphere,c={v3LightPosition:a("v3",new THREE.Vector3(1e8,0,1e8).normalize()),v3InvWavelength:a("v3",new THREE.Vector3(1/Math.pow(b.wavelength[0],4),1/Math.pow(b.wavelength[1],4),1/Math.pow(b.wavelength[2],4))),fCameraHeight:a("f",0),fCameraHeight2:a("f",0),fInnerRadius:a("f",b.innerRadius),fInnerRadius2:a("f",b.innerRadius*b.innerRadius),fOuterRadius:a("f",b.outerRadius),fOuterRadius2:a("f",b.outerRadius*b.outerRadius),fKrESun:a("f",b.Kr*b.ESun),fKmESun:a("f",b.Km*b.ESun),fKr4PI:a("f",4*b.Kr*Math.PI),fKm4PI:a("f",4*b.Km*Math.PI),fScale:a("f",1/(b.outerRadius-b.innerRadius)),fScaleDepth:a("f",b.scaleDepth),fScaleOverScaleDepth:a("f",1/(b.outerRadius-b.innerRadius)/b.scaleDepth),g:a("f",b.g),g2:a("f",b.g*b.g),nSamples:a("i",3),fSamples:a("f",3),tDiffuse:a("t",orb.textures.day),tDiffuseNight:a("t",orb.textures.night),tClouds:a("t",null),fNightScale:a("f",1),fMultiplier:a("f",1)},d=new THREE.SphereGeometry(orb.Constants.Atmosphere.innerRadius,100,100);d=(new THREE.BufferGeometry).fromGeometry(d);var e=new THREE.ShaderMaterial({uniforms:c,vertexShader:orb.Constants.Vertex.Earth,fragmentShader:orb.Constants.Fragment.Earth,depthWrite:!0}),f=new THREE.Mesh(d,e);f.group="globe",this.scene.add(f);var d=new THREE.SphereGeometry(orb.Constants.Atmosphere.outerRadius,100,100);d=(new THREE.BufferGeometry).fromGeometry(d);var e=new THREE.ShaderMaterial({uniforms:c,vertexShader:orb.Constants.Vertex.Sky,fragmentShader:orb.Constants.Fragment.Sky,side:THREE.BackSide,transparent:!0,blending:THREE.AdditiveBlending}),f=new THREE.Mesh(d,e);f.group="globe",this.scene.add(f);var g=new THREE.Vector3(1,1,0),h=(new THREE.Euler(0,0,0),new THREE.Matrix4,0);this.onUpdate=function(){h=orb.core.camera.position.length(),g.set(1,0,0),g.applyMatrix4(orb.time.matrix),c.v3LightPosition.value=g,c.fCameraHeight.value=h,c.fCameraHeight2.value=h*h}},orb.GeometryLayer.prototype=Object.create(orb.Layer.prototype),orb.ParticleLayer=function(a,b){orb.Layer.call(this);for(var c=new THREE.MeshBasicMaterial({color:13986863,map:THREE.ImageUtils.loadTexture(b),transparent:!0,blending:THREE.AdditiveBlending,depthWrite:!1,side:THREE.DoubleSide}),d=new orb.Coordinate,e=new THREE.Vector3,f=0;f<a.length;++f){var g=(a[f].size||1)/5,h=new THREE.PlaneBufferGeometry(g,g),i=new THREE.Mesh(h,c);d.set(a[f].lat,a[f].lng),d.toVector3(orb.Constants.Atmosphere.outerRadius,i.position),i.lookAt(e),this.scene.add(i)}},orb.ParticleLayer.prototype=Object.create(orb.Layer.prototype),orb.RibbonLayer=function(){this.cadence,this.offset,this.positions=[];var a={time:{type:"f",value:1},resolution:{type:"v2",value:new THREE.Vector2(WIDTH,WIDTH)},texture:{type:"t",value:null}};this.passThroughShader=new THREE.ShaderMaterial({uniforms:a,vertexShader:orb.Constants.Vertex.PassThrough,fragmentShader:orb.Constants.Fragment.Shader}),this.stepShader=new THREE.ShaderMaterial({uniforms:a,vertexShader:orb.Constants.Vertex.PassThrough,fragmentShader:orb.Constants.Fragment.Shader})},orb.RibbonLayer.prototype=Object.create(orb.Layer.prototype),orb.RibbonLayer.render=function(a,b,c){renderer.render(scene,camera,b),this.currentPosition=b},orb.RibbonLayer.getRenderTarget=function(a){var b=new THREE.WebGLRenderTarget(WIDTH,WIDTH,{wrapS:THREE.RepeatWrapping,wrapT:THREE.RepeatWrapping,minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:a,type:THREE.FloatType,stencilBuffer:!1});return b},orb.RibbonLayer.generateTexture=function(){for(var a=new Float32Array(3*PARTICLES),b=0,c=a.length;c>b;b+=3){var d=Math.random()-.5,e=Math.random()-.5,f=Math.random()-.5;a[b+0]=10*d,a[b+1]=10*e,a[b+2]=10*f}var g=new THREE.DataTexture(a,WIDTH,WIDTH,THREE.RGBFormat,THREE.FloatType);return g.minFilter=THREE.NearestFilter,g.magFilter=THREE.NearestFilter,g.needsUpdate=!0,g.flipY=!1,g},orb.RibbonLayer.onUpdate=function(){},orb.RibbonGeometry=function(){THREE.BufferGeometry.call(this);var a=new THREE.BufferAttribute(new Float32Array(3*points),3);new THREE.BufferAttribute(new Float32Array(3*points),3);this.addAttribute("position",a),this.addAttribute("reference",referecnes)},orb.RibbonGeometry.prototype=Object.create(THREE.BufferGeometry.prototype),orb.SpaceParticleLayer=function(a){orb.Layer.call(this);for(var b={size:{type:"f",value:[]},ca:{type:"c",value:[]}},c={amplitude:{type:"f",value:1},color:{type:"c",value:new THREE.Color(16777215)},texture:{type:"t",value:THREE.ImageUtils.loadTexture("textures/sprites/disc.png")}},d=new THREE.ShaderMaterial({uniforms:c,attributes:b,vertexShader:orb.Constants.Vertex.Stars,fragmentShader:orb.Constants.Fragment.Stars,transparent:!0}),e=new THREE.Geometry,f=b.size.value,g=b.ca.value,h=0;h<a.length;h+=5){var i=a[h],j=a[h+1],k=a[h+2],l=a[h+3],m=a[h+4],n=Math.floor((l+.4)/5.86*orb.Constants.BV.length);e.vertices.push(new THREE.Vector3(i,j,k).multiplyScalar(1e6)),f.push(m),g.push(new THREE.Color(orb.Constants.BV[n]))}var o=new THREE.PointCloud(e,d);this.scene.add(o);var p=new THREE.AxisHelper(100);this.scene.add(p)},orb.SpaceParticleLayer.prototype=Object.create(orb.Layer.prototype),orb.Coordinate=function(a,b){this.lat=a||0,this.lng=b||0},orb.Coordinate.prototype={constructor:orb.Coordinate,set:function(a,b){this.lat=a,this.lng=b},copy:function(a){this.lng=a.lng,this.lat=a.lat},fromArray:function(a){this.lat=a[0],this.lng=a[1]},toVector3:function(a,b){a=a||1,b=b||new THREE.Vector3;var c=this.lat*(Math.PI/180),d=-this.lng*(Math.PI/180);return b.set(a*Math.cos(d)*Math.cos(c),a*Math.sin(c),a*Math.sin(d)*Math.cos(c))},toString:function(){return this.lat+", "+this.lng}},orb.Coordinate.Ecliptic=function(a,b){this.origin=orb.galactic.Anchor.Common.Sun,this.primary="J2000.0"},orb.Coordinate.Galactic=function(a,b){this.b=a||0,this.l=b||0},orb.Sphere=function(a,b){this.origin=a,this.radius=b},orb.Ray=function(a,b){this.origin=a,this.direction=radius},orb.intersects=function(a,b){var c=a.radius,d=a.origin,e=b.origin,f=b.origin+b.direction,g=f.sub(e),h=e.sub(d),i=g.dot(g),j=2*g.dot(h),k=h.dot(h)-c*c,l=j*j-4*i*k;return l>=0},orb.Region=function(){this.positive=[],this.negative=[],this.computeBounds()},orb.Region.prototype={constructor:orb.Region,computeBounds:function(){this.bounds={};var a=this.bounds.minimum=new THREE.Vector2(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY),b=this.bounds.maximum=new THREE.Vector2(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY);this.positive.forEach(function(c){c.forEach(function(c){a.x=Math.min(a.x,c.x),a.y=Math.min(a.y,c.y),b.x=Math.max(b.x,c.x),b.y=Math.max(b.y,c.y)})})}},orb.Partition=function(){this.points=[],this.regions=[]},orb.Partition.prototype={constructor:orb.Partition,add:function(a){a.origin;return this},remove:function(a){return this},nearest:function(a,b){return[]}},orb.Unit=function(a,b){this.value=a||0,this.unit=b||""},orb.Unit.prototype={constructor:orb.Unit,convert:function(a){},normalize:function(){var a=orb.Unit.Conversions[unit];void 0!=a&&(this.value=this.value*a.ratio,this.unit=a.si)},toString:function(){return value.toExponential+this.unit}},orb.Unit.Conversions={m:{name:"Meter",si:"m",ratio:1},pc:{name:"Parsec",si:"m",ratio:308567758e8},au:{name:"Astronomical Unit",si:"m",ratio:308567758e8},ly:{name:"Light-year",si:"m",ratio:308567758e8}},orb.Unit.Prefix={Y:1e24,Z:1e21,E:1e18,P:1e15,T:1e12,G:1e9,M:1e6,k:1e3,m:.001,u:1e-6,n:1e-9,p:1e-12,f:1e-15,a:1e-18,z:1e-21,y:1e-24,detect:function(a){var b={base:a,prefix:"",ratio:1};if(a.length>1){var c=a.substr(1),d=a.substr(0,1),e=orb.Unit.Prefix[d];void 0!==orb.Unit.Conversions[c]&&void 0!==e&&(b.base=c,b.prefix=d,b.ratio=e)}return b}},orb.Vector3=THREE.Vector3,orb.Vector3.prototype=THREE.Vector3.prototype,orb.Node=function(){this._id=orb.NodeIdCount++,this._uuid="",this._name="",this.parent=void 0,this.children=[],this._attributes={},this._data={}},orb.Node.prototype={attribute:function(a,b){return void 0!==b?(this._attributes[a]=b,this.dispatchEvent({type:"attribute"}),this):this._attributes[a]},add:function(a){a!==this&&a instanceof orb.Node&&(void 0!==a.parent&&a.parent.remove(a),this.children.push(a))},remove:function(a){},traverse:function(a){}},orb.NodeIdCount=0;