/*! Orb.js 24-04-2015 */
"use strict";var orb=orb||{revision:0};orb.Core=function(a){this.layers=[],this.overlays=[],this.animating=!1,this.renderer=new THREE.WebGLRenderer({antialias:!1}),this.scene=new THREE.Scene,this.camera=new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,1,1e12),this.camera.position.z=300;var b=this.renderer;b.setSize(window.innerWidth,window.innerHeight),b.setClearColor(0,1),this.clock=new THREE.Clock,a.appendChild(this.renderer.domElement);var c=this;window.addEventListener("resize",function(){c.camera.aspect=window.innerWidth/window.innerHeight,c.camera.updateProjectionMatrix(),c.renderer.setSize(window.innerWidth,window.innerHeight)},!1)},orb.Core.prototype={constructor:orb.Core,setDate:function(a){return a instanceof Date&&(this._date=a),this},getDate:function(){return void 0===this._date,Date.now()},add:function(a){this.scene.add(a.scene),this.layers.push(a)},remove:function(a){this.scene.remove(a.scene);var b=this.layers.indexOf(a);b>-1&&this.layers.splice(b,1)},start:function(){if(!this.animating){var a=this,b=function(){a.animating&&(requestAnimationFrame(b),a.render())};this.animating=!0,requestAnimationFrame(b)}},stop:function(){this.animating=!1},render:function(){void 0!=orb.trackball&&orb.trackball.update();var a=this.clock.getElapsedTime();orb.time.update(0,50*a);for(var b=0;b<this.layers.length;++b)this.layers[b].onUpdate(a);this.renderer.render(this.scene,this.camera),void 0!==stats&&stats.update()}},orb.Layer=function(){this.scene=new THREE.Object3D},orb.Layer.prototype={constructor:orb.Layer,onUpdate:function(){}},orb.Constants={Fragment:{},Vertex:{}},orb.Constants.Atmosphere={Kr:.0025,Km:.001,ESun:20,g:-.95,wavelength:[.65,.57,.475],scaleDepth:.25,mieScaleDepth:.1,innerRadius:100,outerRadius:101},orb.Constants.BV=[10203903,10401279,10729983,11190271,11716095,12307711,12899071,13424895,13884927,14344959,14673407,15002111,15330559,15659007,15987455,16316159,16710143,16775675,16775157,16774639,16774122,16773605,16773088,16772571,16772054,16771538,16771278,16770762,16770502,16769987,16769727,16769211,16768952,16768436,16767920,16767661,16767145,16766629,16766369,16765596,16765078,16764047,16763013,16761208,16758629,16755019,16749859,16743168,16732672],orb.Constants.Fragment.Earth="//\n// Atmospheric scattering fragment shader\n//\n// Author: Sean O'Neil\n//\n// Copyright (c) 2004 Sean O'Neil\n//\n// Ported for use with three.js/WebGL by James Baicoianu\n\n//uniform sampler2D s2Tex1;\n//uniform sampler2D s2Tex2;\n\nuniform float fNightScale;\nuniform vec3 v3LightPosition;\nuniform sampler2D tDiffuse;\n//uniform sampler2D tDiffuseNight;\n//uniform sampler2D tClouds;\n\nuniform float fMultiplier;\n\nvarying vec3 c0;\nvarying vec3 c1;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main (void)\n{\n	//gl_FragColor = vec4(c0, 1.0);\n	//gl_FragColor = vec4(0.25 * c0, 1.0);\n	//gl_FragColor = gl_Color + texture2D(s2Tex1, gl_TexCoord[0].st) * texture2D(s2Tex2, gl_TexCoord[1].st) * gl_SecondaryColor;\n	float phong = max(dot(normalize(-vNormal), normalize(v3LightPosition)), 0.0);\n\n	vec3 diffuseTex = texture2D( tDiffuse, vUv ).xyz;\n	//vec3 diffuseNightTex = texture2D( tDiffuseNight, vUv ).xyz;\n\n	//diffuseTex = vec3(0.0);\n	//diffuseNightTex = vec3(0.0);\n	//vec3 cloudsTex = texture2D( tClouds, vUv ).xyz;\n\n	//vec3 day = max( diffuseTex, cloudsTex ) * c0;\n	//vec3 night = fNightScale * (0.7 * pow(diffuseNightTex, vec3(3)) + 0.3 * diffuseNightTex) * (1.0 - c0) * phong * (1.0 - cloudsTex);\n\n\n\n	// specular\n	//vec3 r = reflect( -normalize(v3LightPosition), normalize(vNormal) );\n	//float specular =  0.2 * pow(max(dot(r, normalize(cameraPosition)), 0.0), 3.0);\n\n\n\n\n\n	//gl_FragColor = vec4(c1, 1.0) + vec4(day + night, 1.0);\n\n	//gl_FragColor = vec4(fMultiplier * (c1 + day + night), 1.0);\n	gl_FragColor = vec4(c1 + c0 * diffuseTex, 1.0);\n	//gl_FragColor.r += specular;\n	//gl_FragColor.rg += vUv.xy;\n\n}",orb.Constants.Fragment.RibbonUpdate="// update the ribbon shader\n\nvarying vec2 vUv;\n\nuniform sampler2D tPositions;\nuniform sampler2D tVelocities;\n\nuniform float delta;\n\nvoid main() {\n\n	vec2 uv = gl_FragCoord.xy / resolution.xy;\n	vec4 data = texture2D( tPosition, uv );\n	vec3 position = data.xy;\n	vec3 velocity = texture3D( tVelocity, position.xy ).xy;\n\n	// x = lng\n	// y = lat\n	gl_FragColor = vec4( position + velocity * delta, 1., 1. );\n\n}",orb.Constants.Fragment.Sky="//\n// Atmospheric scattering fragment shader\n//\n// Author: Sean O'Neil\n//\n// Copyright (c) 2004 Sean O'Neil\n//\n\nuniform vec3 v3LightPos;\nuniform float g;\nuniform float g2;\n\nuniform float fMultiplier;\n\nvarying vec3 v3Direction;\nvarying vec3 c0;\nvarying vec3 c1;\n\n// Calculates the Mie phase function\nfloat getMiePhase(float fCos, float fCos2, float g, float g2)\n{\n	return 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCos2) / pow(1.0 + g2 - 2.0 * g * fCos, 1.5);\n}\n\n// Calculates the Rayleigh phase function\nfloat getRayleighPhase(float fCos2)\n{\n	return 0.75 + 0.75 * fCos2;\n}\n\nvoid main (void)\n{\n	float fCos = dot(v3LightPos, v3Direction) / length(v3Direction);\n	float fCos2 = fCos * fCos;\n\n	vec3 color =	getRayleighPhase(fCos2) * c0 +\n					getMiePhase(fCos, fCos2, g, g2) * c1;\n\n 	gl_FragColor = vec4(fMultiplier * fMultiplier * color, 1.0);\n	gl_FragColor.a = gl_FragColor.b;\n}",orb.Constants.Fragment.Stars="uniform vec3 color;\nuniform sampler2D texture;\n\nvarying vec3 vColor;\n\nvoid main() {\n\n	gl_FragColor = vec4( color * vColor, 1.0 );\n	//gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );\n	//gl_FragColor = vec4( 1.0, 1.0, 1.0, 1.0 );\n}",orb.Constants.Vertex.Earth="//\n// Atmospheric scattering vertex shader\n//\n// Author: Sean O'Neil\n//\n// Copyright (c) 2004 Sean O'Neil\n//\n// Ported for use with three.js/WebGL by James Baicoianu\n\nuniform vec3 v3LightPosition;		// The direction vector to the light source\nuniform vec3 v3InvWavelength;	// 1 / pow(wavelength, 4) for the red, green, and blue channels\nuniform float fCameraHeight;	// The camera's current height\nuniform float fCameraHeight2;	// fCameraHeight^2\nuniform float fOuterRadius;		// The outer (atmosphere) radius\nuniform float fOuterRadius2;	// fOuterRadius^2\nuniform float fInnerRadius;		// The inner (planetary) radius\nuniform float fInnerRadius2;	// fInnerRadius^2\nuniform float fKrESun;			// Kr * ESun\nuniform float fKmESun;			// Km * ESun\nuniform float fKr4PI;			// Kr * 4 * PI\nuniform float fKm4PI;			// Km * 4 * PI\nuniform float fScale;			// 1 / (fOuterRadius - fInnerRadius)\nuniform float fScaleDepth;		// The scale depth (i.e. the altitude at which the atmosphere's average density is found)\nuniform float fScaleOverScaleDepth;	// fScale / fScaleDepth\nuniform sampler2D tDiffuse;\n\nvarying vec3 v3Direction;\nvarying vec3 c0;\nvarying vec3 c1;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nconst int nSamples = 3;\nconst float fSamples = 3.0;\n\nfloat scale(float fCos)\n{\n	float x = 1.0 - fCos;\n	return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\n\nvoid main(void)\n{\n	// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n	vec3 v3Ray = position - cameraPosition;\n	float fFar = length(v3Ray);\n	v3Ray /= fFar;\n\n	// Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\n	float B = 2.0 * dot(cameraPosition, v3Ray);\n	float C = fCameraHeight2 - fOuterRadius2;\n	float fDet = max(0.0, B*B - 4.0 * C);\n	float fNear = 0.5 * (-B - sqrt(fDet));\n\n	// Calculate the ray's starting position, then calculate its scattering offset\n	vec3 v3Start = cameraPosition + v3Ray * fNear;\n	fFar -= fNear;\n	float fDepth = exp((fInnerRadius - fOuterRadius) / fScaleDepth);\n	float fCameraAngle = dot(-v3Ray, position) / length(position);\n	float fLightAngle = dot(v3LightPosition, position) / length(position);\n	float fCameraScale = scale(fCameraAngle);\n	float fLightScale = scale(fLightAngle);\n	float fCameraOffset = fDepth*fCameraScale;\n	float fTemp = (fLightScale + fCameraScale);\n\n	// Initialize the scattering loop variables\n	float fSampleLength = fFar / fSamples;\n	float fScaledLength = fSampleLength * fScale;\n	vec3 v3SampleRay = v3Ray * fSampleLength;\n	vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n	// Now loop through the sample rays\n	vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n	vec3 v3Attenuate;\n	for(int i=0; i<nSamples; i++)\n	{\n		float fHeight = length(v3SamplePoint);\n		float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n		float fScatter = fDepth*fTemp - fCameraOffset;\n		v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n		v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n		v3SamplePoint += v3SampleRay;\n	}\n\n	// Calculate the attenuation factor for the ground\n	c0 = v3Attenuate;\n	c1 = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\n\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n	//gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;\n	//gl_TexCoord[1] = gl_TextureMatrix[1] * gl_MultiTexCoord1;\n	vUv = uv;\n	vNormal = normal;\n}",orb.Constants.Vertex.EarthMap="//\n// Atmospheric scattering vertex shader\n//\n// Author: Sean O'Neil\n//\n// Copyright (c) 2004 Sean O'Neil\n//\n// Ported for use with three.js/WebGL by James Baicoianu\n\nuniform vec3 v3LightPosition;		// The direction vector to the light source\nuniform vec3 v3InvWavelength;	// 1 / pow(wavelength, 4) for the red, green, and blue channels\nuniform float fCameraHeight;	// The camera's current height\nuniform float fCameraHeight2;	// fCameraHeight^2\nuniform float fOuterRadius;		// The outer (atmosphere) radius\nuniform float fOuterRadius2;	// fOuterRadius^2\nuniform float fInnerRadius;		// The inner (planetary) radius\nuniform float fInnerRadius2;	// fInnerRadius^2\nuniform float fKrESun;			// Kr * ESun\nuniform float fKmESun;			// Km * ESun\nuniform float fKr4PI;			// Kr * 4 * PI\nuniform float fKm4PI;			// Km * 4 * PI\nuniform float fScale;			// 1 / (fOuterRadius - fInnerRadius)\nuniform float fScaleDepth;		// The scale depth (i.e. the altitude at which the atmosphere's average density is found)\nuniform float fScaleOverScaleDepth;	// fScale / fScaleDepth\nuniform sampler2D tDiffuse;\n\nvarying vec3 v3Direction;\nvarying vec3 c0;\nvarying vec3 c1;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nconst int nSamples = 3;\nconst float fSamples = 3.0;\n\nfloat scale(float fCos)\n{\n	float x = 1.0 - fCos;\n	return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\n\nvoid main(void)\n{\n	// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n	float theta = (uv.y) * 3.1415;\n	float phi = (uv.x) * 2.0 * 3.1415;\n\n	vec3 v3position = -vec3( fInnerRadius * sin(theta) * cos(phi), fInnerRadius * sin(theta) * sin(phi), fInnerRadius * cos(theta) );\n	vec3 v3camera = 6.0 * v3position;\n	float ffCameraHeight = length(v3camera);\n	float ffCameraHeight2 = ffCameraHeight * ffCameraHeight;\n	vec3 v3Ray = v3position - v3camera;\n	float fFar = length(v3Ray);\n	v3Ray /= fFar;\n\n	// Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\n	float B = 2.0 * dot(v3camera, v3Ray);\n	float C = ffCameraHeight2 - fOuterRadius2;\n	float fDet = max(0.0, B*B - 4.0 * C);\n	float fNear = 0.5 * (-B - sqrt(fDet));\n\n	// Calculate the ray's starting position, then calculate its scattering offset\n	vec3 v3Start = v3camera + v3Ray * fNear;\n	fFar -= fNear;\n	float fDepth = exp((fInnerRadius - fOuterRadius) / fScaleDepth);\n	float fCameraAngle = dot(-v3Ray, v3position) / length(v3position);\n	float fLightAngle = dot(v3LightPosition, v3position) / length(v3position);\n	float fCameraScale = scale(fCameraAngle);\n	float fLightScale = scale(fLightAngle);\n	float fCameraOffset = fDepth*fCameraScale;\n	float fTemp = (fLightScale + fCameraScale);\n\n	// Initialize the scattering loop variables\n	float fSampleLength = fFar / fSamples;\n	float fScaledLength = fSampleLength * fScale;\n	vec3 v3SampleRay = v3Ray * fSampleLength;\n	vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n	// Now loop through the sample rays\n	vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n	vec3 v3Attenuate;\n	for(int i=0; i < nSamples; i++)\n	{\n		float fHeight = length(v3SamplePoint);\n		float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n		float fScatter = fDepth*fTemp - fCameraOffset;\n		v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n		v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n		v3SamplePoint += v3SampleRay;\n	}\n\n	// Calculate the attenuation factor for the ground\n	c0 = v3Attenuate;\n	c1 = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\n	//c0 = vec3( uv.u, uv.v, 0 );\n\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n	//gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;\n	//gl_TexCoord[1] = gl_TextureMatrix[1] * gl_MultiTexCoord1;\n	vUv = uv;\n	vNormal = normal;\n}",orb.Constants.Vertex.RibbonUpdate="varying vec2 vUv;\n\nvoid main() {\n\n	vUv = vec2(uv.x, 1.0 - uv.y);\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}",orb.Constants.Vertex.Sky="//\n// Atmospheric scattering vertex shader\n//\n// Author: Sean O'Neil\n//\n// Copyright (c) 2004 Sean O'Neil\n//\n\nuniform vec3 v3LightPosition;	// The direction vector to the light source\nuniform vec3 v3InvWavelength;	// 1 / pow(wavelength, 4) for the red, green, and blue channels\nuniform float fCameraHeight;	// The camera's current height\nuniform float fCameraHeight2;	// fCameraHeight^2\nuniform float fOuterRadius;		// The outer (atmosphere) radius\nuniform float fOuterRadius2;	// fOuterRadius^2\nuniform float fInnerRadius;		// The inner (planetary) radius\nuniform float fInnerRadius2;	// fInnerRadius^2\nuniform float fKrESun;			// Kr * ESun\nuniform float fKmESun;			// Km * ESun\nuniform float fKr4PI;			// Kr * 4 * PI\nuniform float fKm4PI;			// Km * 4 * PI\nuniform float fScale;			// 1 / (fOuterRadius - fInnerRadius)\nuniform float fScaleDepth;		// The scale depth (i.e. the altitude at which the atmosphere's average density is found)\nuniform float fScaleOverScaleDepth;	// fScale / fScaleDepth\n\nconst int nSamples = 3;\nconst float fSamples = 3.0;\n\nvarying vec3 v3Direction;\nvarying vec3 c0;\nvarying vec3 c1;\n\n\nfloat scale(float fCos)\n{\n	float x = 1.0 - fCos;\n	return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\n\nvoid main(void)\n{\n	// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n	vec3 v3Ray = position - cameraPosition;\n	float fFar = length(v3Ray);\n	v3Ray /= fFar;\n\n	// Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\n	float B = 2.0 * dot(cameraPosition, v3Ray);\n	float C = fCameraHeight2 - fOuterRadius2;\n	float fDet = max(0.0, B*B - 4.0 * C);\n	float fNear = 0.5 * (-B - sqrt(fDet));\n\n	// Calculate the ray's starting position, then calculate its scattering offset\n	vec3 v3Start = cameraPosition + v3Ray * fNear;\n	fFar -= fNear;\n	float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;\n	float fStartDepth = exp(-1.0 / fScaleDepth);\n	float fStartOffset = fStartDepth * scale(fStartAngle);\n	//c0 = vec3(1.0, 0, 0) * fStartAngle;\n\n	// Initialize the scattering loop variables\n	float fSampleLength = fFar / fSamples;\n	float fScaledLength = fSampleLength * fScale;\n	vec3 v3SampleRay = v3Ray * fSampleLength;\n	vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n	//gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);\n\n	// Now loop through the sample rays\n	vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n	for(int i=0; i<nSamples; i++)\n	{\n		float fHeight = length(v3SamplePoint);\n		float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n		float fLightAngle = dot(v3LightPosition, v3SamplePoint) / fHeight;\n		float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight;\n		float fScatter = (fStartOffset + fDepth * (scale(fLightAngle) - scale(fCameraAngle)));\n		vec3 v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n\n		v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n		v3SamplePoint += v3SampleRay;\n	}\n\n	// Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n	c0 = v3FrontColor * (v3InvWavelength * fKrESun);\n	c1 = v3FrontColor * fKmESun;\n	v3Direction = cameraPosition - position;\n}",orb.Constants.Vertex.Stars="attribute float size;\nattribute vec3 ca;\n\nvarying vec3 vColor;\n\nvoid main() {\n\n	vColor = ca;\n\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n	//gl_PointSize = size;\n	//gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );\n	gl_PointSize = 1.5;\n\n	gl_Position = projectionMatrix * mvPosition;\n\n}",orb.time={day:0,minute:0,declination:0,spin:0,euler:new THREE.Euler,matrix:new THREE.Matrix4,update:function(a,b){for(void 0!==a&&void 0!=b&&(this.day=a,this.minute=b);this.minute>1440;)this.minute-=1440,this.day+=1;this.day>365&&(this.day=this.day%365),this.declination=-23.45*Math.PI/180*Math.cos(2*Math.PI/365*(this.day+10)),this.spin=-2*Math.PI*(this.minute/1440),this.euler.y=this.spin+Math.PI,this.euler.z=this.declination,this.matrix.makeRotationFromEuler(this.euler)}},orb.ArcGeometry=function(a,b,c){THREE.Geometry.call(this);for(var d=a.toVector3(),e=b.toVector3(),f=10,g=0;f+1>g;++g){var h=(new THREE.Vector3).copy(d);h.lerp(e,g/f),h.normalize().multiplyScalar(c),this.vertices.push(h)}},orb.ArcGeometry.prototype=Object.create(THREE.Geometry.prototype),orb.RibbonGeometry=function(){THREE.Geometry.call(this)},orb.RibbonGeometry.prototype=Object.create(THREE.Geometry.prototype),orb.ArcLayer=function(a){orb.Layer.call(this);for(var b=new THREE.LineBasicMaterial({color:16777215}),c=0;c<a.length;++c){var d=a[c],e=d[0],f=d[1],g=new orb.ArcGeometry(e,f,100),h=new THREE.Line(g,b);this.scene.add(h)}},orb.ArcLayer.prototype=Object.create(orb.Layer.prototype),orb.AtmosphericLayer=function(){},orb.AtmosphericLayer.prototype=Object.create(orb.Layer.prototype),orb.AtmosphericInLayer=function(){},orb.AtmosphericOutLayer=function(){},orb.BarDataLayer=function(a){var b=[14277081,11973813,10053324,1420799,4089507,2187912,16744062,16719635,12587531,5903105,16763906,15577363,10473062,825913,16685170,8339352,15885602,2864755,14147363,15118906,8311799];orb.Layer.call(this);for(var c=new THREE.Geometry,d=new THREE.MeshBasicMaterial({color:13986863,depthWrite:!1,depthTest:!1,blending:THREE.AdditiveBlending,vertexColors:THREE.FaceColors,transparent:!0}),e=new orb.Coordinate,f=new THREE.Vector3,g=new THREE.BoxGeometry(1,1,1),h=new THREE.Mesh(g,void 0),i=0;i<a.length;i+=4){for(var j=a[i],k=a[i+1],l=Math.max(200*a[i+2],.1),m=a[i+3],n=new THREE.Color(b[m]),o=0;o<g.faces.length;o++)g.faces[o].color=n;e.set(j,k),e.toVector3(orb.Constants.Atmosphere.outerRadius,h.position),h.scale.set(.5,.5,l),h.lookAt(f),h.updateMatrix(),c.merge(h.geometry,h.matrix)}var p=new THREE.Mesh(c,d);this.scene.add(p)},orb.BarDataLayer.prototype=Object.create(orb.Layer.prototype),orb.FieldLayer=function(){this.lifespan=1,this.density=1e4,this.resolution=10,this.buffer=new Float32Array(this.density*this.resolution),this.geometry=new THREE.BufferedGeometry;this.geometry.attributes},orb.FieldLayer.prototype={constructor:orb.FieldLayer,update:function(){},randomPoint:function(){var a=Math.random(),b=Math.random(),c=2*Math.PI*a,d=Math.acos(2*b-1);return THREE.Vector3(Math.sin(c)*Math.cos(d),Math.sin(c)*Math.sin(d),Math.cos(c))}},orb.MapLayer=function(){orb.Layer.call(this),orb.textures={day:THREE.ImageUtils.loadTexture("textures/map-small.jpg")};var a=function(a,b){return{type:a,value:b}},b=orb.Constants.Atmosphere,c={v3LightPosition:a("v3",new THREE.Vector3(1e8,0,1e8).normalize()),v3InvWavelength:a("v3",new THREE.Vector3(1/Math.pow(b.wavelength[0],4),1/Math.pow(b.wavelength[1],4),1/Math.pow(b.wavelength[2],4))),fCameraHeight:a("f",0),fCameraHeight2:a("f",0),fInnerRadius:a("f",b.innerRadius),fInnerRadius2:a("f",b.innerRadius*b.innerRadius),fOuterRadius:a("f",b.outerRadius),fOuterRadius2:a("f",b.outerRadius*b.outerRadius),fKrESun:a("f",b.Kr*b.ESun),fKmESun:a("f",b.Km*b.ESun),fKr4PI:a("f",4*b.Kr*Math.PI),fKm4PI:a("f",4*b.Km*Math.PI),fScale:a("f",1/(b.outerRadius-b.innerRadius)),fScaleDepth:a("f",b.scaleDepth),fScaleOverScaleDepth:a("f",1/(b.outerRadius-b.innerRadius)/b.scaleDepth),g:a("f",b.g),g2:a("f",b.g*b.g),nSamples:a("i",3),fSamples:a("f",3),tDiffuse:a("t",orb.textures.day),tDiffuseNight:a("t",orb.textures.night),tClouds:a("t",null),fNightScale:a("f",1),fMultiplier:a("f",1)},d=new THREE.PlaneGeometry(200,100,100,50),e=new THREE.ShaderMaterial({uniforms:c,vertexShader:orb.Constants.Vertex.EarthMap,fragmentShader:orb.Constants.Fragment.Earth,depthWrite:!0}),f=new THREE.Mesh(d,e);f.group="globe",this.scene.add(f);var g=new THREE.Vector3(1,1,0),h=(new THREE.Euler(0,0,0),new THREE.Matrix4,0);this.onUpdate=function(){h=orb.core.camera.position.length(),g.set(1,0,0),g.applyMatrix4(orb.time.matrix),c.v3LightPosition.value=g,c.fCameraHeight.value=h,c.fCameraHeight2.value=h*h}},orb.MapLayer.prototype=Object.create(orb.Layer.prototype),orb.GeometryLayer=function(){orb.Layer.call(this),orb.textures={day:THREE.ImageUtils.loadTexture("textures/map-small.jpg")};var a=function(a,b){return{type:a,value:b}},b=orb.Constants.Atmosphere,c={v3LightPosition:a("v3",new THREE.Vector3(1e8,0,1e8).normalize()),v3InvWavelength:a("v3",new THREE.Vector3(1/Math.pow(b.wavelength[0],4),1/Math.pow(b.wavelength[1],4),1/Math.pow(b.wavelength[2],4))),fCameraHeight:a("f",0),fCameraHeight2:a("f",0),fInnerRadius:a("f",b.innerRadius),fInnerRadius2:a("f",b.innerRadius*b.innerRadius),fOuterRadius:a("f",b.outerRadius),fOuterRadius2:a("f",b.outerRadius*b.outerRadius),fKrESun:a("f",b.Kr*b.ESun),fKmESun:a("f",b.Km*b.ESun),fKr4PI:a("f",4*b.Kr*Math.PI),fKm4PI:a("f",4*b.Km*Math.PI),fScale:a("f",1/(b.outerRadius-b.innerRadius)),fScaleDepth:a("f",b.scaleDepth),fScaleOverScaleDepth:a("f",1/(b.outerRadius-b.innerRadius)/b.scaleDepth),g:a("f",b.g),g2:a("f",b.g*b.g),nSamples:a("i",3),fSamples:a("f",3),tDiffuse:a("t",orb.textures.day),tDiffuseNight:a("t",orb.textures.night),tClouds:a("t",null),fNightScale:a("f",1),fMultiplier:a("f",1)},d=new THREE.SphereGeometry(orb.Constants.Atmosphere.innerRadius,100,100),e=new THREE.ShaderMaterial({uniforms:c,vertexShader:orb.Constants.Vertex.Earth,fragmentShader:orb.Constants.Fragment.Earth,depthWrite:!0}),f=new THREE.Mesh(d,e);f.group="globe",this.scene.add(f);var d=new THREE.SphereGeometry(orb.Constants.Atmosphere.outerRadius,100,100),e=new THREE.ShaderMaterial({uniforms:c,vertexShader:orb.Constants.Vertex.Sky,fragmentShader:orb.Constants.Fragment.Sky,side:THREE.BackSide,transparent:!0,blending:THREE.AdditiveBlending}),f=new THREE.Mesh(d,e);f.group="globe",this.scene.add(f);var g=new THREE.Vector3(1,1,0),h=(new THREE.Euler(0,0,0),new THREE.Matrix4,0);this.onUpdate=function(){h=orb.core.camera.position.length(),g.set(1,0,0),g.applyMatrix4(orb.time.matrix),c.v3LightPosition.value=g,c.fCameraHeight.value=h,c.fCameraHeight2.value=h*h}},orb.GeometryLayer.prototype=Object.create(orb.Layer.prototype),orb.ParticleLayer=function(a,b){orb.Layer.call(this);for(var c=new THREE.MeshBasicMaterial({color:13986863,map:THREE.ImageUtils.loadTexture(b),transparent:!0,blending:THREE.AdditiveBlending,depthWrite:!1,side:THREE.DoubleSide}),d=new orb.Coordinate,e=new THREE.Vector3,f=0;f<a.length;++f){var g=(a[f].size||1)/5,h=new THREE.PlaneBufferGeometry(g,g),i=new THREE.Mesh(h,c);d.set(a[f].lat,a[f].lng),d.toVector3(orb.Constants.Atmosphere.outerRadius,i.position),i.lookAt(e),this.scene.add(i)}},orb.ParticleLayer.prototype=Object.create(orb.Layer.prototype),orb.RibbonLayer=function(){this.cadence,this.offset,this.positions=[];var a={time:{type:"f",value:1},resolution:{type:"v2",value:new THREE.Vector2(WIDTH,WIDTH)},texture:{type:"t",value:null}};this.passThroughShader=new THREE.ShaderMaterial({uniforms:a,vertexShader:orb.Constants.Vertex.PassThrough,fragmentShader:orb.Constants.Fragment.Shader}),this.stepShader=new THREE.ShaderMaterial({uniforms:a,vertexShader:orb.Constants.Vertex.PassThrough,fragmentShader:orb.Constants.Fragment.Shader})},orb.RibbonLayer.prototype=Object.create(orb.Layer.prototype),orb.RibbonLayer.render=function(a,b){renderer.render(scene,camera,b),this.currentPosition=b},orb.RibbonLayer.getRenderTarget=function(a){var b=new THREE.WebGLRenderTarget(WIDTH,WIDTH,{wrapS:THREE.RepeatWrapping,wrapT:THREE.RepeatWrapping,minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:a,type:THREE.FloatType,stencilBuffer:!1});return b},orb.RibbonLayer.generateTexture=function(){for(var a=new Float32Array(3*PARTICLES),b=0,c=a.length;c>b;b+=3){var d=Math.random()-.5,e=Math.random()-.5,f=Math.random()-.5;a[b+0]=10*d,a[b+1]=10*e,a[b+2]=10*f}var g=new THREE.DataTexture(a,WIDTH,WIDTH,THREE.RGBFormat,THREE.FloatType);return g.minFilter=THREE.NearestFilter,g.magFilter=THREE.NearestFilter,g.needsUpdate=!0,g.flipY=!1,g},orb.RibbonLayer.onUpdate=function(){},orb.RibbonGeometry=function(){THREE.BufferGeometry.call(this);{var a=new THREE.BufferAttribute(new Float32Array(3*points),3);new THREE.BufferAttribute(new Float32Array(3*points),3)}this.addAttribute("position",a),this.addAttribute("reference",referecnes)},orb.RibbonGeometry.prototype=Object.create(THREE.BufferGeometry.prototype),orb.SpaceParticleLayer=function(a){orb.Layer.call(this);for(var b={size:{type:"f",value:[]},ca:{type:"c",value:[]}},c={amplitude:{type:"f",value:1},color:{type:"c",value:new THREE.Color(16777215)},texture:{type:"t",value:THREE.ImageUtils.loadTexture("textures/sprites/disc.png")}},d=new THREE.ShaderMaterial({uniforms:c,attributes:b,vertexShader:orb.Constants.Vertex.Stars,fragmentShader:orb.Constants.Fragment.Stars,transparent:!0}),e=new THREE.Geometry,f=b.size.value,g=b.ca.value,h=0;h<a.length;h+=5){var i=a[h],j=a[h+1],k=a[h+2],l=a[h+3],m=a[h+4],n=Math.floor((l+.4)/5.86*orb.Constants.BV.length);e.vertices.push(new THREE.Vector3(i,j,k).multiplyScalar(1e6)),f.push(m),g.push(new THREE.Color(orb.Constants.BV[n]))}var o=new THREE.PointCloud(e,d);this.scene.add(o);var p=new THREE.AxisHelper(100);this.scene.add(p)},orb.SpaceParticleLayer.prototype=Object.create(orb.Layer.prototype),orb.Coordinate=function(a,b){this.lat=a||0,this.lng=b||0},orb.Coordinate.prototype={constructor:orb.Coordinate,set:function(a,b){this.lat=a,this.lng=b},copy:function(a){this.lng=a.lng,this.lat=a.lat},fromArray:function(a){this.lat=a[0],this.lng=a[1]},toVector3:function(a,b){a=a||1,b=b||new THREE.Vector3;var c=this.lat*(Math.PI/180),d=-this.lng*(Math.PI/180);return b.set(a*Math.cos(d)*Math.cos(c),a*Math.sin(c),a*Math.sin(d)*Math.cos(c))},toString:function(){return this.lat+", "+this.lng}},orb.Coordinate.Ecliptic=function(){this.origin=orb.galactic.Anchor.Common.Sun,this.primary="J2000.0"},orb.Coordinate.Galactic=function(a,b){this.b=a||0,this.l=b||0},orb.Sphere=function(a,b){this.origin=a,this.radius=b},orb.Ray=function(a){this.origin=a,this.direction=radius},orb.intersects=function(a,b){var c=a.radius,d=a.origin,e=b.origin,f=b.origin+b.direction,g=f.sub(e),h=e.sub(d),i=g.dot(g),j=2*g.dot(h),k=h.dot(h)-c*c,l=j*j-4*i*k;return l>=0},orb.Region=function(){this.positive=[],this.negative=[],this.computeBounds()},orb.Region.prototype={constructor:orb.Region,computeBounds:function(){this.bounds={};var a=this.bounds.minimum=new THREE.Vector2(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY),b=this.bounds.maximum=new THREE.Vector2(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY);this.positive.forEach(function(c){c.forEach(function(c){a.x=Math.min(a.x,c.x),a.y=Math.min(a.y,c.y),b.x=Math.max(b.x,c.x),b.y=Math.max(b.y,c.y)})})}},orb.Partition=function(){this.points=[],this.regions=[]},orb.Partition.prototype={constructor:orb.Partition,add:function(a){a.origin;return this},remove:function(){return this},nearest:function(){return[]}},orb.Unit=function(a,b){this.value=a||0,this.unit=b||""},orb.Unit.prototype={constructor:orb.Unit,convert:function(){},normalize:function(){var a=orb.Unit.Conversions[unit];void 0!=a&&(this.value=this.value*a.ratio,this.unit=a.si)},toString:function(){return value.toExponential+this.unit}},orb.Unit.Conversions={m:{name:"Meter",si:"m",ratio:1},pc:{name:"Parsec",si:"m",ratio:308567758e8},au:{name:"Astronomical Unit",si:"m",ratio:308567758e8},ly:{name:"Light-year",si:"m",ratio:308567758e8}},orb.Unit.Prefix={Y:1e24,Z:1e21,E:1e18,P:1e15,T:1e12,G:1e9,M:1e6,k:1e3,m:.001,u:1e-6,n:1e-9,p:1e-12,f:1e-15,a:1e-18,z:1e-21,y:1e-24,detect:function(a){var b={base:a,prefix:"",ratio:1};if(a.length>1){var c=a.substr(1),d=a.substr(0,1),e=orb.Unit.Prefix[d];void 0!==orb.Unit.Conversions[c]&&void 0!==e&&(b.base=c,b.prefix=d,b.ratio=e)}return b}},orb.Vector3=THREE.Vector3,orb.Vector3.prototype=THREE.Vector3.prototype,orb.Node=function(){this._id=orb.NodeIdCount++,this._uuid="",this._name="",this.parent=void 0,this.children=[],this._attributes={},this._data={}},orb.Node.prototype={attribute:function(a,b){return void 0!==b?(this._attributes[a]=b,this.dispatchEvent({type:"attribute"}),this):this._attributes[a]},add:function(a){a!==this&&a instanceof orb.Node&&(void 0!==a.parent&&a.parent.remove(a),this.children.push(a))},remove:function(){},traverse:function(){}},orb.NodeIdCount=0;